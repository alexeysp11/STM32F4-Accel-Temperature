# Теория по I2C 

## Общий теоретический материал 

В *теории информации* и *computer science* система имеет состояния, если она способна запоминать предшествующие события. 
Тогда вся запомненная информация называется **состоянием** системы. 

В дискретных системах пространство состояний *исчисляемо* и *конечно*. 

**Синхронной схемой** называется цифровая схема, в которой изменение состояний элементов в памяти синхронизируется с помощью *сигнала тактирования*. 

*Сигнал тактирования* колеблется между высоким и низким уровнем и меняет своё состояние на противоположное через равные промежутки времени (причём промежуток времени между сменой состояний можно задавать программно). 
Используется он для координации действий цифровых схем. 

![ClockSignal](https://learn.circuitverse.org/assets/images/clock_signal.jpg)

Сигнал тактирования вырабатывается *тактовым генератором*.
Большинство интегральных схем используют *тактовый сигнал* для синхронизации различных частей схемы. 
При этом циклическая смена состояний (с высокого на низкий уровень и наоборот) производится со скоростью, меньшей, чем внутренние задержки микросхемы в наихудшем случае.

## Общая информация про I2C 

**I2C** (**Inter-Integrated Circuit**) - это синхронная шина последовательной передачи данных, реализующая пакетную передачу данных, поддерживающая несколько master-устройств и несколько slave-устройств. 

*I2C* широко используется для присоединения к процессору *периферийных устройств*, работающих на более низких частотах. 

Особым достоинством I2C является способность микроконтроллера управлять целой сетью из устройств с помощью всего двух выводов **GPIO**. 

![I2C bus](https://lh3.googleusercontent.com/proxy/NcUw3bjz4d-uOloUbahKnlfLH4HjWGOX6cawglj_b2P8lgEBU0bcZxmRVL57PID5mv4JIUjJSQve0heudo9HNLp86neL3r9Gd2fldiUA9BI2yDhSWvk)

Многие другие технологии, использующие общую шину для передачи данных между устройствами (например, *SPI*), для подключения нескольких устройств требуют значительно большего количества контактов.

I2C использует только две двунаправленные линии с *открытым коллектором* или *открытым стоком* (в том, чем отличаются *Open drain* и *Open collector*, и в чём их суть, я не успел разобраться), а также последовательную линию передачи данных (SDA) и последовательную линию синхронизации (SCL), подтянутых резисторами к питанию (собственно, это изображено на рисунке сверху). 
Обычно используются напряжения +5 В или +3,3 В, хотя разрешены системы с другими напряжениями. 

*I2C* имеет 7-битное адресное пространство с редко используемым 10-битным расширением. 
Обычными скоростями шины *I2C* являются стандартный режим 100 кбит/с и высокоскоростной режим 400 кбит/с. 

Служебные данные протокола включают адрес подчиненного устройства и, возможно, адрес регистра в подчиненном устройстве, а также побайтовые биты ACK/NACK. 

Таким образом, фактическая скорость передачи пользовательских данных ниже, чем предполагают только эти пиковые скорости передачи данных. Например, если каждое взаимодействие с ведомым устройством неэффективно позволяет передавать только 1 байт данных, скорость передачи данных будет меньше половины максимальной скорости передачи битов.

Количество узлов, которые могут существовать на данной шине I2C, ограничено адресным пространством. 

Протокол I2C позволяет с помощью двух проводов соединить большое количество устройств из-за того, что у каждого отдельного устройства есть свой ID. 

Шина имеет две роли для узлов, т.е. Master и Slave:
Master узел - узел, который генерирует тактовую частоту и инициирует связь с ведомыми устройствами.
Slave узел - узел, принимающий тактовую частоту и отвечающий на обращение ведущего.

Шина I2C является шиной с несколькими ведущими, что означает, что может присутствовать любое количество Master-узлов. 
Кроме того, Master и Slave могут меняться между собой ролями в периодах между отправкой сообщений (обычно после отправки *STOP*).

Для каждого устройства шины может быть четыре возможных режима работы в зависимости от того, кто кому шлёт сообщения, и кто является ведущим/ведомым:
- *master transmit* - ведущий узел отправляет данные ведомому,
- *master receive* - мастер-узел получает данные от ведомого,
- *slave transmit* - подчиненный узел отправляет данные мастеру,
- *slave receive* - подчиненный узел получает данные от мастера.

## Алгоритм работы с I2C

Последовательность заполнения данных представлена на рисунке ниже: 

![](https://www.digikey.be/maker-media/98f1d94e-d1a0-403f-9afd-baecd0e8afb2)

Изначально Master находится в режиме *master transmit*, отправляет START и затем 7-битный адрес slave-устройства, с которым он хочет связаться. 
Затем, наконец, следует один бит, указывающий, хочет ли Master записать данные в регистр данных slave-устройства (тогда ставит 0) или прочитать данные от slave-устройства (тогда ставит 1).

Если slave-устройство существует на шине, оно ответит битом ACK (активный низкий уровень для подтверждения) для этого адреса. 
Затем ведущее и ведомое устройство продолжают работу в режиме передачи или приема (в зависимости от отправленного им бита чтения/записи).

Байты адреса и данных передаются первым старшим битом (MSB). 
Если ведущее устройство желает записать данные в ведомое устройство, оно повторно отправляет байт, при этом ведомое устройство отправляет бит ACK. 

Если ведущий желает читать с ведомого, то он многократно получает байт от ведомого, причем ведущий отправляет бит ACK после каждого байта, кроме последнего. 

Транзакция I2C может состоять из нескольких сообщений. 
Мастер завершает сообщение условием STOP, если это конец транзакции, или он может отправить другое условие START, чтобы сохранить контроль над шиной для другого сообщения (транзакция «комбинированного формата»).

## Список использованной литературы 

1. https://en.wikipedia.org/wiki/State_(computer_science)
1. https://en.wikipedia.org/wiki/Synchronous_circuit
1. https://hubstub.ru/stm32/152-push-pull-vs-open-drain.html
1. https://en.wikipedia.org/wiki/I%C2%B2C
