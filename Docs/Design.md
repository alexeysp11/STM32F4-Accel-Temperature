# Design 

Техническое задание представлено [здесь](https://github.com/lamer0k/Lections/blob/master/%D0%9A%D1%83%D1%80%D1%81%D0%BE%D0%B2%D0%BE%D0%B9%20%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%205.pdf).  

[Здесь](About.md) представлено общее описание приложения. 

## Проектирование графического интерфейса

Примерное графическое представление системы изображено на рисунке снизу: 

![UserInterface](img/GuiDrafts/UserInterface.png)

<!--
Примерные координаты визуальных объектов: 

![CoordinatesOfVisualObjects](img/CoordinatesOfVisualObjects.png)
-->

## Обзор системы

<!--
Из каких модулей будет состоять система, и каким образом будет производиться взаимодействие между ними? 
-->

Система состоит из следующих компонентов:
- Акселерометр **ADXL345** (для измерения векторов ускорения по каждой из осей); 
- Встроенный датчик температуры (для измерения окружающей температуры); 
- **I2C** (для передачи данных с акселерометра на микроконтроллер); 
- **USART** (для передачи данных с микроконтроллера на компьютер); 
- Программа в виде *графического интерфейса* (для визуального отображения углов поворота объекта в пространстве, ускорений и температуры).  

На рисунке ниже представлена **схема соединения** составных компонентов системы на аппаратном уровне: 

![SystemOverview](img/SystemOverview.png)

Для корректной работы программы критически важно **устанавливать задержку** на передачу данных с микроконтроллера на компьютер, чтобы программа верхнего уровня не зависала. 
Потому что когда идёт постоянный поток данных, в лучшем случае программа верхнего уровня на **WPF** перестаёт реагировать на какие-либо воздействия, но чаще всего программа вылетает с исключением **APPCRASH**. 

**Настройка конфигурации портов** (контроль чётности, количество стоп бит, количество бит данных, скорость передачи) **производится в самом коде** специально под технические требования. 

*Здесь будут примеры кода для модуля верхнего уровня и модуля нижнего уровня*. 
<!--
Для модуля верхнего уровня: 
```C#

```

Для модуля нижнего уровня: 
```C#

```
-->

Один раз в *100 мс* микроконтроллер отсылает данные, измеренные с помощью *гироскопа* и *акселерометра*, на компьютер.

Для того, чтобы было удобнее распаковать на компьютере данные, полученные с микроконтроллера, был придуман **формат пакета**, который будет использоваться конкретно под данную систему: 

![UartPacket](img/DataTransmission/UartPacket.png)

Первый бит является служебным и содержит в себе значение для кодирования либо буквы "А" (если передаются данные акселерометра), либо буквы "T" (если передаётся значение температуры). 

Получается, что в одной посылке таких пакетов должно быть 4 штуки (3 для *акселерометра* и 1 для *датчика температуры*). 

*CRC* позволяет оценить целостность данных при отправке. 
Если данные всё-таки были искажены при отправке (т.е. когда *CRC* не будет совпадать), то эти искажённые данные просто будут игнорироваться.  
Таким образом, в данном приложении реализуется аналог *UDP-протокола*. 

## Проектирование архитектуры

**Диаграмма состояний** всей системы (включая *графическую* и *измерительную* подсистему) представлена на рисунке ниже: 

![StatechartSystem](img/UML/StatechartSystem.png)

<!--Перепроверить диаграммы компонентов, преобразовать их в диаграммы пакетов (библиотек)-->
**Диаграмма компонентов** для *измерительной части* системы может выглядеть следующим образом: 

![MeasuringSystemComponents](img/UML/MeasuringSystemComponents.png)

**Диаграмма компонентов** для *графической части* системы может выглядеть следующим образом: 

![GraphicalSystemComponents](img/UML/GraphicalSystemComponents.png)

Диаграмма классов графической подсистемы приложения представлена на рисунке ниже: 

![MeasuringSystemClassDiagramOverall](img/UML/MeasuringSystemClassDiagramOverall.png)

Полное описание классов представлено по [ссылке](ClassDescriptions.md). 

В *графической подсистеме*, наверное, нужно будет реализовывать шаблон **Singleton** (для того, чтобы предотвратить двойное создание таких объектов как *плата* и *COM-порт*) и **Наблюдатель** (для отслеживания наличия изменений *вектора состояния* платы). 
Ещё должна быть осуществлена распаковка *посылки* из пакетов измеренных значений.  

В *измерительной подсистеме* используется операционная система **FreeRTOS** как каркас для всего приложения, и всё приложение, по сути, будет зависеть от архитектуры **FreeRTOS**. 

<!--
Насколько я понял, на плате есть пины и названия пинов на самой плате соответствуют пинам, с которыми идёт взаимодействие в программе. 

Микроконтроллер - это master receiver, а гироскоп и акселерометр - это slave transmitter. 

На рисунке ниже представлена принципиальная схема устройства: 
-->
